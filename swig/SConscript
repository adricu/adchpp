Import('dev source_path')

targets = []
build_path = dev.get_build_path(source_path)

def runCommand(cmd):
	import os
	try:
		i, o = os.popen4(cmd)
		i.close()
		output = o.read()
		o.close()
		return output
	except Exception,e:
		return ""

def getRbConf(name):
	if dev.env['PLATFORM'] == 'win32':
		return runCommand("ruby -rmkmf -e \"print Config.expand('$(" + name + ")')\"")
	else:
		return runCommand("ruby -rmkmf -e \"print Config.expand('\$(" + name + ")')\"")

def buildRbModule():
	if not runCommand("ruby -v"):
		print "Ruby not found"
		return
	
	env = dev.env.Copy()
	
	env.Append(SWIGFLAGS=['-c++','-Wall','-ruby'])
	f = env.CFile(target=dev.get_build_path(source_path) + 'ruby_wrap.cxx', source='ruby.i')
	
	import distutils.sysconfig
	
	libdir = getRbConf("libdir")
	if not libdir:
		print "Ruby libdir not found"
		return 
	
	incdir = getRbConf("archdir")
	if not incdir:
		print "Ruby archdir not found"
		return

	soname = getRbConf("RUBY_SO_NAME")
	if not soname:
		print "Ruby RUBY_SO_NAME not found"
		return
	
	if '_DEBUG' in env['CPPDEFINES']:
		env['CPPDEFINES'].remove('_DEBUG')
	
	env.Append(LIBPATH=[libdir])
	env.Append(CPPPATH=['#', incdir])
	env.Append(LIBS=[soname, 'adchpp'])
		
	rb = env.SharedLibrary(dev.get_target(source_path, 'rbadchpp'), [f],
						SHLIBPREFIX='')
	targets.append(rb)

def buildPyModule():
	import sys
	if dev.is_win32() and sys.platform != 'win32':
		print "Cross-compiling python module not supported"
		return

	env, target, sources = dev.prepare_build(source_path, '_pyadchpp', 'python.i')
	env.Append(SWIGFLAGS=['-c++','-threads','-Wall','-python', '-O', '-classic'])

	import distutils.sysconfig,distutils.cygwinccompiler
	
	env.Append(CPPPATH=['#', distutils.sysconfig.get_python_inc()])
	if '_DEBUG' in env['CPPDEFINES']:
		env['CPPDEFINES'].remove('_DEBUG')
	if '/MDd' in env['CCFLAGS']:
		env['CCFLAGS'].remove('/MDd')
		env['CCFLAGS'].append('/MD')

	if 'mingw' in env['TOOLS']:
		compiler = distutils.cygwinccompiler.Mingw32CCompiler()
		env.Append(LIBS=compiler.dll_libraries)

	import os,distutils,sys
	if env['PLATFORM'] == 'win32':
		if 'mingw' in env['TOOLS']:
			env.Append(LIBPATH=[distutils.sysconfig.get_config_var('prefix')])
		else:
			env.Append(LIBPATH=[os.path.join(distutils.sysconfig.get_config_var('prefix'),"libs")])
		env.Append(LIBS=["python"+"".join(sys.version[0:3].split(".")), 'adchpp'])
	else:
		env.Append(LIBS=['python2.4', 'adchpp'])
	
	wrapper = build_path + 'python_wrap.cc'
	pyfile = build_path + 'pyadchpp.py'
	pytarget = dev.get_target(source_path, 'pyadchpp.py')
	env.SideEffect(pyfile, wrapper)
	env.Command(pytarget, pyfile, Copy('$TARGET', '$SOURCE'))
	env.Depends(pytarget, pyfile)
	
	pyd = env.SharedLibrary(target, sources, SHLIBPREFIX='')
	env.Depends(pyd, pytarget)

	targets.append(pyd)

def buildLuaModule():
	env, target, sources = dev.prepare_build(source_path, 'luadchpp', 'lua.i')
	
	env.Append(SWIGFLAGS=['-c++','-Wall','-lua'])
	
	env.Append(LIBS=['adchpp', 'alua'])
	# We assume the lua from the script plugin will be used...
	
	env.Append(CPPPATH=['#', '#/lua/'])
	
	if env['PLATFORM'] == 'win32':
		env.Append(CPPDEFINES=['LUA_BUILD_AS_DLL=1'])
	else:
		env.Append(CPPDEFINES=['LUA_USE_LINUX=1'])

	luadchpp = env.SharedLibrary(target, sources, SHLIBPREFIX='')
	targets.append(luadchpp)

# buildRbModule() - needs threading sorted out
buildPyModule()

buildLuaModule()

Return('targets')
